// Autogenerated from development/flavors/base_flavor_profile.i

package ideal.development.flavors;

import ideal.library.elements.*;
import ideal.runtime.elements.*;
import ideal.runtime.logs.*;
import ideal.development.elements.*;
import ideal.development.names.*;

import javax.annotation.Nullable;

public class base_flavor_profile extends debuggable implements flavor_profile, readonly_displayable {
  private final string name;
  private final function1<type_flavor, type_flavor> flavor_map;
  private @Nullable immutable_list<type_flavor> cached_flavors;
  public base_flavor_profile(final string name, final function1<type_flavor, type_flavor> flavor_map) {
    this.name = name;
    this.flavor_map = flavor_map;
  }
  public type_flavor map(final type_flavor from) {
    return flavor_map.call(from);
  }
  public @Override type_flavor default_flavor() {
    return map(flavor.DEFAULT_FLAVOR);
  }
  public @Override boolean supports(final type_flavor flavor) {
    return map(flavor) == flavor;
  }
  public @Override immutable_list<type_flavor> supported_flavors() {
    final @Nullable immutable_list<type_flavor> result = cached_flavors;
    if (result == null) {
      final base_list<type_flavor> filtered_flavors = new base_list<type_flavor>();
      final immutable_list<type_flavor> primary_flavors = flavor.PRIMARY_FLAVORS;
      for (int i = 0; i < primary_flavors.size(); i += 1) {
        final type_flavor the_flavor = primary_flavors.get(i);
        if (this.supports(the_flavor)) {
          filtered_flavors.append(the_flavor);
        }
      }
      final immutable_list<type_flavor> new_result = filtered_flavors.frozen_copy();
      cached_flavors = new_result;
      return new_result;
    } else {
      return result;
    }
  }
  public @Override string to_string() {
    return name;
  }
  public @Override string display() {
    return name;
  }
}
