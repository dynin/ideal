// Autogenerated from development/names/operator.i

package ideal.development.names;

import ideal.library.elements.*;
import ideal.runtime.elements.*;
import ideal.runtime.logs.*;
import ideal.development.elements.*;
import ideal.development.symbols.base_symbols;
import static ideal.development.names.operator_type.*;

public class operator extends debuggable implements action_name {
  public final operator_type the_operator_type;
  public final token_type name;
  public final simple_name alpha_name;
  protected operator(final operator_type the_operator_type, final token_type name, final string alpha_name) {
    this.the_operator_type = the_operator_type;
    this.name = name;
    this.alpha_name = simple_name.make(alpha_name);
  }
  public simple_name symbol() {
    return this.alpha_name;
  }
  public string to_string() {
    return name_utilities.in_brackets(ideal.machine.elements.runtime_util.concatenate(ideal.machine.elements.runtime_util.concatenate(this.the_operator_type, new base_string(" ")), this.name));
  }
  public static final operator ASSIGN = new operator(operator_type.INFIX, punctuation.EQUALS, new base_string("assign"));
  public static final operator MULTIPLY = new operator(operator_type.INFIX, punctuation.ASTERISK, new base_string("multiply"));
  public static final operator DIVIDE = new operator(operator_type.INFIX, punctuation.SLASH, new base_string("divide"));
  public static final operator MODULO = new operator(operator_type.INFIX, punctuation.PERCENT, new base_string("modulo"));
  public static final operator ADD = new operator(operator_type.INFIX, punctuation.PLUS, new base_string("add"));
  public static final operator SUBTRACT = new operator(operator_type.INFIX, punctuation.MINUS, new base_string("subtract"));
  public static final operator NEGATE = new operator(operator_type.PREFIX, punctuation.MINUS, new base_string("negate"));
  public static final operator PRE_INCREMENT = new operator(operator_type.PREFIX, punctuation.PLUS_PLUS, new base_string("pre_increment"));
  public static final operator CONCATENATE = new operator(operator_type.INFIX, punctuation.PLUS_PLUS, new base_string("concatenate"));
  public static final operator EQUAL_TO = new operator(operator_type.INFIX, punctuation.EQUALS_EQUALS, new base_string("equal_to"));
  public static final operator NOT_EQUAL_TO = new operator(operator_type.INFIX, punctuation.EXCLAMATION_MARK_EQUALS, new base_string("not_equal_to"));
  public static final operator LESS = new operator(operator_type.INFIX, punctuation.LESS_THAN, new base_string("less"));
  public static final operator GREATER = new operator(operator_type.INFIX, punctuation.GREATER_THAN, new base_string("greater"));
  public static final operator LESS_EQUAL = new operator(operator_type.INFIX, punctuation.LESS_THAN_EQUALS, new base_string("less_equal"));
  public static final operator GREATER_EQUAL = new operator(operator_type.INFIX, punctuation.GREATER_THAN_EQUALS, new base_string("greater_equal"));
  public static final operator BIT_AND = new operator(operator_type.INFIX, punctuation.AMPERSAND, new base_string("bit_and"));
  public static final operator XOR = new operator(operator_type.INFIX, punctuation.CARET, new base_string("xor"));
  public static final operator BIT_OR = new operator(operator_type.INFIX, punctuation.VERTICAL_BAR, new base_string("bit_or"));
  public static final operator LOGICAL_AND = new operator(operator_type.INFIX, punctuation.AMPERSAND_AMPERSAND, new base_string("logical_and"));
  public static final operator LOGICAL_OR = new operator(operator_type.INFIX, punctuation.VERTICAL_BAR_VERTICAL_BAR, new base_string("logical_or"));
  public static final operator LOGICAL_NOT = new operator(operator_type.PREFIX, punctuation.EXCLAMATION_MARK, new base_string("logical_not"));
  public static final operator GENERAL_OR = new operator(operator_type.INFIX, keywords.OR, new base_string("general_or"));
  public static final operator ADD_ASSIGN = new operator(operator_type.INFIX, punctuation.PLUS_EQUALS, new base_string("add_assign"));
  public static final operator SUBTRACT_ASSIGN = new operator(operator_type.INFIX, punctuation.MINUS_EQUALS, new base_string("subtract_assign"));
  public static final operator MULTIPLY_ASSIGN = new operator(operator_type.INFIX, punctuation.ASTERISK_EQUALS, new base_string("multiply_assign"));
  public static final operator CONCATENATE_ASSIGN = new operator(operator_type.INFIX, punctuation.PLUS_PLUS_EQUALS, new base_string("concatenate_assign"));
  public static final cast_type SOFT_CAST = new cast_type(punctuation.DOT_GREATER_THAN, new base_string("soft_cast"));
  public static final cast_type HARD_CAST = new cast_type(punctuation.EXCLAMATION_GREATER_THAN, new base_string("hard_cast"));
  public static final operator IS_OPERATOR = new operator(operator_type.INFIX, keywords.IS, new base_string("is_operator"));
  public static final operator IS_NOT_OPERATOR = new operator(operator_type.INFIX, keywords.IS_NOT, new base_string("is_not_operator"));
  public static final operator ALLOCATE = new operator(operator_type.PREFIX, keywords.NEW, new base_string("allocate"));
}
