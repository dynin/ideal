// Autogenerated from development/notifications/error_signal.i

package ideal.development.notifications;

import ideal.library.elements.*;
import ideal.library.channels.*;
import ideal.library.texts.*;
import ideal.library.messages.*;
import ideal.runtime.elements.*;
import ideal.runtime.texts.*;
import ideal.runtime.logs.*;
import ideal.development.elements.*;
import ideal.development.origins.*;

public class error_signal extends debuggable implements signal, analyzable {
  public final notification cause;
  public final boolean is_cascading;
  public error_signal(final notification cause, final boolean is_cascading) {
    this.cause = cause;
    this.is_cascading = is_cascading;
  }
  public error_signal(final string message, final origin the_origin) {
    this(new base_notification(message, the_origin), false);
  }
  public error_signal(final string message, final analyzable primary, final origin the_origin) {
    final analysis_result analyzed = primary.analyze();
    assert analyzed instanceof error_signal;
    this.cause = new base_notification(message, the_origin, new base_immutable_list<notification>(new ideal.machine.elements.array<notification>(new notification[]{ ((error_signal) analyzed).cause })));
    this.is_cascading = true;
  }
  public @Override origin deeper_origin() {
    return this.cause.origin();
  }
  public @Override boolean has_errors() {
    return true;
  }
  public @Override error_signal analyze() {
    return this;
  }
  public @Override readonly_list<analyzable> children() {
    return new empty<analyzable>();
  }
  public void report_not_cascading() {
    if (!this.is_cascading) {
      this.cause.report();
    }
  }
  public @Override analyzable specialize(final specialization_context context, final principal_type new_parent) {
    return this;
  }
  public @Override string to_string() {
    return this.cause.to_string();
  }
}
