// Autogenerated from development/scanners/base_scanner_config.i

package ideal.development.scanners;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.library.patterns.*;
import ideal.runtime.elements.*;
import ideal.runtime.characters.*;
import ideal.runtime.patterns.*;
import ideal.runtime.logs.*;
import ideal.machine.characters.*;
import ideal.machine.channels.string_writer;
import ideal.development.elements.*;
import ideal.development.names.*;
import ideal.development.notifications.*;
import ideal.development.origins.*;
import ideal.development.comments.*;
import ideal.development.literals.*;
import ideal.development.modifiers.*;
import ideal.development.constructs.constraint_category;
import ideal.development.jumps.jump_category;

import javax.annotation.Nullable;

public class base_scanner_config implements scanner_config {
  private final hash_dictionary<simple_name, base_scanner_config.token_matcher> keyword_dictionary = new hash_dictionary<simple_name, base_scanner_config.token_matcher>();
  private final base_list<scanner_element> elements_list = new base_list<scanner_element>();
  public @Override character_handler the_character_handler() {
    return unicode_handler.instance;
  }
  public @Override boolean is_whitespace(final char the_character) {
    return this.the_character_handler().is_whitespace(the_character);
  }
  public @Override boolean is_name_start(final char the_character) {
    return this.the_character_handler().is_letter(the_character) || the_character == '_';
  }
  public @Override boolean is_name_part(final char the_character) {
    return this.the_character_handler().is_letter_or_digit(the_character) || the_character == '_';
  }
  public @Override readonly_list<scanner_element> elements() {
    return this.elements_list;
  }
  public readonly_list<token<Object>> scan(final source_content source) {
    return new scanner_engine(this).scan(source);
  }
  public @Override token<Object> process_token(final token<Object> the_token) {
    if (the_token.type() == special_token_type.SIMPLE_NAME) {
      final simple_name the_name = ((token<simple_name>) (Object) the_token).payload();
      final @Nullable base_scanner_config.token_matcher matcher = this.keyword_dictionary.get(the_name);
      if (matcher != null) {
        final @Nullable origin the_origin = the_token.deeper_origin();
        assert the_origin != null;
        return matcher.process(the_origin);
      }
    }
    return the_token;
  }
  public void add(final scanner_element element) {
    assert element instanceof base_scanner_element;
    ((base_scanner_element) element).set_config(this);
    this.elements_list.append(((base_scanner_element) element));
  }
  private void do_add_keyword(final simple_name name, final base_scanner_config.token_matcher matcher) {
    final @Nullable base_scanner_config.token_matcher old = this.keyword_dictionary.put(name, matcher);
    assert old == null;
  }
  public void add_keyword(final keyword the_keyword) {
    this.do_add_keyword(simple_name.make(the_keyword.name()), new base_scanner_config.base_token_matcher<keyword>(the_keyword, the_keyword));
  }
  public void add_punctuation(final punctuation_type the_punctuation_type) {
    this.add(new punctuation_element(the_punctuation_type));
  }
  public void add_special(final special_name the_special_name, final token_type the_token_type) {
    this.do_add_keyword(simple_name.make(the_token_type.name()), new base_scanner_config.base_token_matcher<special_name>(special_token_type.SPECIAL_NAME, the_special_name));
  }
  public void add_kind(final kind the_kind) {
    this.do_add_keyword(the_kind.name(), new base_scanner_config.base_token_matcher<kind>(special_token_type.KIND, the_kind));
  }
  public void add_subtype_tag(final subtype_tag tag) {
    this.do_add_keyword(tag.name(), new base_scanner_config.base_token_matcher<subtype_tag>(special_token_type.SUBTYPE_TAG, tag));
  }
  public void add_modifier(final modifier_kind modifier) {
    this.do_add_keyword(modifier.name(), new base_scanner_config.base_token_matcher<modifier_kind>(special_token_type.MODIFIER_KIND, modifier));
  }
  public void add_flavor(final type_flavor flavor) {
    this.do_add_keyword(flavor.name(), new base_scanner_config.base_token_matcher<type_flavor>(special_token_type.FLAVOR, flavor));
  }
  public void add_jump(final jump_category jump) {
    this.do_add_keyword(jump.jump_name(), new base_scanner_config.base_token_matcher<jump_category>(special_token_type.JUMP, jump));
  }
  public void add_constraint(final constraint_category constraint) {
    this.do_add_keyword(constraint.constraint_name(), new base_scanner_config.base_token_matcher<constraint_category>(special_token_type.CONSTRAINT, constraint));
  }
  public @Override void add_reserved(final string reserved_word, @Nullable keyword the_keyword) {
    final simple_name name = simple_name.make(reserved_word);
    if (the_keyword == null) {
      the_keyword = keywords.RESERVED;
    }
    this.do_add_keyword(name, new base_scanner_config.base_token_matcher<keyword>(keywords.RESERVED, the_keyword));
  }
  private static interface any_token_matcher extends any_value { }
  private static interface readonly_token_matcher extends readonly_value, any_token_matcher { }
  private static interface writeonly_token_matcher extends writeonly_value, any_token_matcher { }
  private static interface token_matcher extends value, readonly_token_matcher, writeonly_token_matcher {
    token<Object> process(origin the_origin);
  }
  private static interface immutable_token_matcher extends immutable_value, readonly_token_matcher { }
  private static interface deeply_immutable_token_matcher extends deeply_immutable_value, immutable_token_matcher { }
  private static class base_token_matcher<payload_type> implements base_scanner_config.token_matcher {
    private final token_type the_token_type;
    private final payload_type payload;
    public base_token_matcher(final token_type the_token_type, final payload_type payload) {
      assert payload != null;
      this.the_token_type = the_token_type;
      this.payload = payload;
    }
    public @Override token<Object> process(final origin the_origin) {
      return ((token<Object>) (Object) new base_token<payload_type>(this.the_token_type, this.payload, the_origin));
    }
  }
  public base_scanner_config() { }
}
