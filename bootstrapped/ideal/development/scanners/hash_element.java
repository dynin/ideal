// Autogenerated from development/scanners/hash_element.i

package ideal.development.scanners;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.library.patterns.*;
import ideal.runtime.elements.*;
import ideal.runtime.characters.*;
import ideal.runtime.patterns.*;
import ideal.runtime.logs.*;
import ideal.machine.characters.*;
import ideal.machine.channels.string_writer;
import ideal.development.elements.*;
import ideal.development.names.*;
import ideal.development.notifications.*;
import ideal.development.origins.*;
import ideal.development.comments.*;
import ideal.development.literals.*;
import ideal.development.modifiers.*;
import ideal.development.constructs.constraint_category;
import ideal.development.jumps.jump_category;

import javax.annotation.Nullable;

public class hash_element extends base_scanner_element {
  private final punctuation_type the_token_type;
  private final char hash_character;
  private static final list_pattern<Character> ID_PATTERN = new list_pattern<Character>(new base_string("id:"));
  public hash_element(final punctuation_type the_token_type) {
    this.the_token_type = the_token_type;
    final string name = the_token_type.name();
    assert ideal.machine.elements.runtime_util.values_equal(name.size(), 1);
    this.hash_character = name.first();
  }
  public @Override @Nullable scan_state process(final source_content source, final Integer begin) {
    final string input = source.content;
    if (input.get(begin) != this.hash_character) {
      return null;
    }
    final Integer end = begin + 1;
    final @Nullable Integer match = hash_element.ID_PATTERN.match_prefix(input.skip(end));
    if (match != null) {
      final Integer identifier_begin = end + match;
      if (identifier_begin < input.size() && this.config().is_name_start(input.get(identifier_begin))) {
        Integer identifier_end = identifier_begin + 1;
        for (; identifier_end < input.size(); identifier_end += 1) {
          if (!this.config().is_name_part(input.get(identifier_end))) {
            break;
          }
        }
        final origin the_origin = source.make_origin(begin, identifier_end);
        final simple_name token_as_name = simple_name.make(source.content.slice(identifier_begin, identifier_end));
        return new scan_state(new base_token<simple_name>(special_token_type.SIMPLE_NAME, token_as_name, the_origin), identifier_end, identifier_end);
      }
    }
    final origin the_origin = source.make_origin(begin, end);
    final string image = input.slice(begin, end);
    return new scan_state(new base_token<string>(this.the_token_type, image, the_origin), end, end);
  }
}
