// Autogenerated from development/scanners/scanner_engine.i

package ideal.development.scanners;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.library.patterns.*;
import ideal.runtime.elements.*;
import ideal.runtime.characters.*;
import ideal.runtime.patterns.*;
import ideal.runtime.logs.*;
import ideal.machine.characters.*;
import ideal.machine.channels.string_writer;
import ideal.development.elements.*;
import ideal.development.names.*;
import ideal.development.notifications.*;
import ideal.development.origins.*;
import ideal.development.comments.*;
import ideal.development.literals.*;
import ideal.development.modifiers.*;
import ideal.development.constructs.constraint_category;
import ideal.development.jumps.jump_category;

import javax.annotation.Nullable;

public class scanner_engine {
  private final scanner_config config;
  public scanner_engine(final scanner_config config) {
    this.config = config;
  }
  public readonly_list<token<Object>> scan(final source_content source) {
    final string input = source.content;
    final base_list<token<Object>> tokens = new base_list<token<Object>>();
    for (Integer begin = 0; begin < input.size();) {
      final char the_character = input.get(begin);
      if (this.config.is_whitespace(the_character)) {
        Integer end = begin + 1;
        for (; end < input.size(); end += 1) {
          if (!this.config.is_whitespace(input.get(end))) {
            break;
          }
        }
        final origin the_origin = source.make_origin(begin, end);
        final string image = input.slice(begin, end);
        final base_token<comment> the_token = new base_token<comment>(special_token_type.COMMENT, new comment(comment_type.WHITESPACE, image, image), the_origin);
        tokens.append(((token<Object>) (Object) the_token));
        begin = end;
      } else if (this.config.is_name_start(the_character)) {
        Integer end = begin + 1;
        for (; end < input.size(); end += 1) {
          if (!this.config.is_name_part(input.get(end))) {
            break;
          }
        }
        final origin the_origin = source.make_origin(begin, end);
        final string image = input.slice(begin, end);
        final simple_name token_as_name = simple_name.make(image);
        final base_token<simple_name> the_token = new base_token<simple_name>(special_token_type.SIMPLE_NAME, token_as_name, the_origin);
        tokens.append(this.config.process_token(((token<Object>) (Object) the_token)));
        begin = end;
      } else {
        @Nullable scan_state next = null;
        {
          final readonly_list<scanner_element> element_list = this.config.elements();
          for (Integer element_index = 0; element_index < element_list.size(); element_index += 1) {
            final scanner_element element = element_list.get(element_index);
            final @Nullable scan_state processed = element.process(source, begin);
            if (processed != null) {
              if (next == null) {
                next = processed;
              } else {
                final Integer compare = processed.compare_to(next);
                assert !ideal.machine.elements.runtime_util.values_equal(compare, 0);
                if (compare > 0) {
                  next = processed;
                }
              }
            }
          }
        }
        if (next != null) {
          tokens.append(next.token);
          begin = next.end;
          continue;
        }
        final Integer end = begin + 1;
        final origin the_origin = source.make_origin(begin, end);
        new base_notification(messages.unrecognized_character, the_origin).report();
        begin = end;
      }
    }
    return tokens;
  }
}
