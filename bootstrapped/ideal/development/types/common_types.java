// Autogenerated from development/types/common_types.i

package ideal.development.types;

import ideal.library.elements.*;
import ideal.library.reflections.*;
import ideal.runtime.elements.*;
import ideal.runtime.logs.*;
import ideal.development.elements.*;
import ideal.development.names.*;
import ideal.development.flavors.*;
import ideal.development.declarations.*;
import ideal.development.kinds.*;
import static ideal.development.names.common_names.*;
import static ideal.development.kinds.type_kinds.*;
import static ideal.development.flavors.flavor_profiles.*;

public class common_types {
  private static type_declaration_context context;
  private static principal_type ideal_type;
  private static principal_type library_type;
  private static principal_type elements_type;
  private static principal_type operators_type;
  private static principal_type VOID_TYPE;
  private static principal_type UNDEFINED_TYPE;
  private static principal_type ENTITY_TYPE;
  private static principal_type VALUE_TYPE;
  private static principal_type DATA_TYPE;
  private static principal_type INTEGER_TYPE;
  private static principal_type NONNEGATIVE_TYPE;
  private static principal_type BOOLEAN_TYPE;
  private static principal_type CHARACTER_TYPE;
  private static principal_type STRING_TYPE;
  private static principal_type NULL_TYPE;
  private static principal_type MISSING_TYPE;
  private static master_type REFERENCE_TYPE;
  private static master_type PROCEDURE_TYPE;
  private static master_type FUNCTION_TYPE;
  private static master_type STRINGABLE_TYPE;
  private static master_type EQUALITY_COMPARABLE_TYPE;
  private static master_type REFERENCE_EQUALITY_TYPE;
  private static master_type LIST_TYPE;
  public common_types(final type_declaration_context context) {
    common_types.context = context;
    elementary_types.set_context(context);
    common_types.ideal_type = common_types.make_namespace(common_names.ideal_name, elementary_types.root_type(), type_kinds.namespace_kind);
    common_types.library_type = common_types.make_namespace(common_names.library_name, common_types.ideal_type, type_kinds.namespace_kind);
    common_types.elements_type = common_types.make_namespace(common_names.elements_name, common_types.library_type, type_kinds.package_kind);
    common_types.operators_type = common_types.make_namespace(common_names.operators_name, common_types.library_type, type_kinds.package_kind);
    common_types.VOID_TYPE = common_types.get_type(common_names.void_name, type_kinds.singleton_kind, flavor_profiles.deeply_immutable_profile);
    common_types.UNDEFINED_TYPE = common_types.get_type(common_names.undefined_name, type_kinds.singleton_kind, flavor_profiles.deeply_immutable_profile);
    common_types.ENTITY_TYPE = common_types.get_type(common_names.entity_name, type_kinds.concept_kind, flavor_profiles.mutable_profile);
    common_types.VALUE_TYPE = common_types.get_type(common_names.value_name, type_kinds.concept_kind, flavor_profiles.mutable_profile);
    common_types.DATA_TYPE = common_types.get_type(common_names.data_name, type_kinds.concept_kind, flavor_profiles.mutable_profile);
    common_types.BOOLEAN_TYPE = common_types.get_type(common_names.boolean_name, type_kinds.enum_kind, flavor_profiles.deeply_immutable_profile);
    common_types.CHARACTER_TYPE = common_types.get_type(common_names.character_name, type_kinds.datatype_kind, flavor_profiles.deeply_immutable_profile);
    common_types.INTEGER_TYPE = common_types.get_type(common_names.integer_name, type_kinds.datatype_kind, flavor_profiles.deeply_immutable_profile);
    common_types.NONNEGATIVE_TYPE = common_types.get_type(common_names.nonnegative_name, type_kinds.datatype_kind, flavor_profiles.deeply_immutable_profile);
    common_types.STRING_TYPE = common_types.get_type(common_names.string_name, type_kinds.datatype_kind, flavor_profiles.deeply_immutable_profile);
    common_types.NULL_TYPE = common_types.get_type(common_names.null_name, type_kinds.interface_kind, flavor_profiles.deeply_immutable_profile);
    common_types.MISSING_TYPE = common_types.get_type(common_names.missing_name, type_kinds.singleton_kind, flavor_profiles.deeply_immutable_profile);
    common_types.REFERENCE_TYPE = common_types.get_type(common_names.reference_name, type_kinds.reference_kind, flavor_profiles.mutable_profile);
    common_types.REFERENCE_TYPE.make_parametrizable();
    common_types.PROCEDURE_TYPE = common_types.get_type(common_names.procedure_name, type_kinds.procedure_kind, flavor_profiles.immutable_profile);
    common_types.PROCEDURE_TYPE.make_parametrizable();
    common_types.FUNCTION_TYPE = common_types.get_type(common_names.function_name, type_kinds.procedure_kind, flavor_profiles.deeply_immutable_profile);
    common_types.FUNCTION_TYPE.make_parametrizable();
    common_types.STRINGABLE_TYPE = common_types.get_type(common_names.stringable_name, type_kinds.interface_kind, flavor_profiles.mutable_profile);
    common_types.EQUALITY_COMPARABLE_TYPE = common_types.get_type(common_names.equality_comparable_name, type_kinds.concept_kind, flavor_profiles.mutable_profile);
    common_types.REFERENCE_EQUALITY_TYPE = common_types.get_type(common_names.reference_equality_name, type_kinds.interface_kind, flavor_profiles.mutable_profile);
    common_types.LIST_TYPE = common_types.get_type(common_names.list_name, type_kinds.interface_kind, flavor_profiles.mutable_profile);
    common_types.LIST_TYPE.make_parametrizable();
  }
  public static principal_type void_type() {
    return common_types.VOID_TYPE;
  }
  public static principal_type undefined_type() {
    return common_types.UNDEFINED_TYPE;
  }
  public static principal_type entity_type() {
    return common_types.ENTITY_TYPE;
  }
  public static principal_type value_type() {
    return common_types.VALUE_TYPE;
  }
  public static principal_type data_type() {
    return common_types.DATA_TYPE;
  }
  public static principal_type boolean_type() {
    return common_types.BOOLEAN_TYPE;
  }
  public static principal_type character_type() {
    return common_types.CHARACTER_TYPE;
  }
  public static principal_type integer_type() {
    return common_types.INTEGER_TYPE;
  }
  public static principal_type nonnegative_type() {
    return common_types.NONNEGATIVE_TYPE;
  }
  public static type immutable_void_type() {
    return common_types.void_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static type immutable_boolean_type() {
    return common_types.boolean_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static type immutable_integer_type() {
    return common_types.integer_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static type immutable_nonnegative_type() {
    return common_types.nonnegative_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static type immutable_character_type() {
    return common_types.character_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static principal_type string_type() {
    return common_types.STRING_TYPE;
  }
  public static type immutable_string_type() {
    return common_types.string_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static master_type stringable_type() {
    return common_types.STRINGABLE_TYPE;
  }
  public static principal_type equality_comparable_type() {
    return common_types.EQUALITY_COMPARABLE_TYPE;
  }
  public static principal_type reference_equality_type() {
    return common_types.REFERENCE_EQUALITY_TYPE;
  }
  public static master_type list_type() {
    return common_types.LIST_TYPE;
  }
  public static type list_type_of(final type element_type) {
    return common_types.LIST_TYPE.bind_parameters(new type_parameters(new base_immutable_list<abstract_value>(new ideal.machine.elements.array<abstract_value>(new abstract_value[]{ (abstract_value) element_type }))));
  }
  public static boolean is_list_type(final type the_type) {
    final principal_type principal = the_type.principal();
    if (principal instanceof parametrized_type) {
      return ((parametrized_type) principal).get_master() == common_types.LIST_TYPE;
    } else {
      return false;
    }
  }
  public static type get_list_parameter(final type list_type) {
    final parametrized_type the_parametrized_type = (parametrized_type) list_type.principal();
    assert the_parametrized_type.get_master() == common_types.LIST_TYPE;
    return (type) the_parametrized_type.get_parameters().the_list.first();
  }
  public static principal_type null_type() {
    return common_types.NULL_TYPE;
  }
  public static type immutable_null_type() {
    return common_types.null_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static principal_type missing_type() {
    return common_types.MISSING_TYPE;
  }
  public static type immutable_missing_type() {
    return common_types.missing_type().get_flavored(flavor.deeply_immutable_flavor);
  }
  public static type get_reference(final type_flavor flavor, final type value_type) {
    return common_types.REFERENCE_TYPE.bind_parameters(new type_parameters(new base_immutable_list<abstract_value>(new ideal.machine.elements.array<abstract_value>(new abstract_value[]{ (abstract_value) value_type })))).get_flavored(flavor);
  }
  public static boolean is_reference_type(final type the_type) {
    final principal_type principal = the_type.principal();
    if (principal instanceof parametrized_type) {
      return ((parametrized_type) principal).get_master() == common_types.REFERENCE_TYPE;
    } else {
      return false;
    }
  }
  public static type get_reference_parameter(final type ref_type) {
    final parametrized_type the_parametrized_type = (parametrized_type) ref_type.principal();
    assert the_parametrized_type.get_master() == common_types.REFERENCE_TYPE;
    return (type) the_parametrized_type.get_parameters().the_list.first();
  }
  public static master_type procedure_type() {
    return common_types.PROCEDURE_TYPE;
  }
  public static master_type function_type() {
    return common_types.FUNCTION_TYPE;
  }
  public static master_type master_procedure(final boolean is_function) {
    return is_function ? common_types.FUNCTION_TYPE : common_types.PROCEDURE_TYPE;
  }
  public static type make_procedure(final boolean is_function, final abstract_value return_value) {
    return common_types.master_procedure(is_function).bind_parameters(new type_parameters(new base_immutable_list<abstract_value>(new ideal.machine.elements.array<abstract_value>(new abstract_value[]{ return_value })))).get_flavored(flavor.immutable_flavor);
  }
  public static type make_procedure(final boolean is_function, final abstract_value return_value, final abstract_value first_argument) {
    return common_types.master_procedure(is_function).bind_parameters(new type_parameters(new base_immutable_list<abstract_value>(new ideal.machine.elements.array<abstract_value>(new abstract_value[]{ return_value, first_argument })))).get_flavored(flavor.immutable_flavor);
  }
  public static type make_procedure(final boolean is_function, final abstract_value return_value, final abstract_value first_argument, final abstract_value second_argument) {
    return common_types.master_procedure(is_function).bind_parameters(new type_parameters(new base_immutable_list<abstract_value>(new ideal.machine.elements.array<abstract_value>(new abstract_value[]{ return_value, first_argument, second_argument })))).get_flavored(flavor.immutable_flavor);
  }
  public static principal_type ideal_namespace() {
    return common_types.ideal_type;
  }
  public static principal_type library_namespace() {
    return common_types.library_type;
  }
  public static principal_type elements_package() {
    return common_types.elements_type;
  }
  public static principal_type operators_package() {
    return common_types.operators_type;
  }
  private static master_type get_type(final action_name name, final kind the_kind, final flavor_profile the_flavor_profile) {
    return common_types.context.get_or_create_type(name, the_kind, common_types.elements_type, the_flavor_profile);
  }
  private static principal_type make_namespace(final action_name name, final principal_type parent, final kind the_kind) {
    final master_type result = common_types.context.get_or_create_type(name, the_kind, parent, flavor_profiles.nameonly_profile);
    result.process_declaration(declaration_pass.METHODS_AND_VARIABLES);
    return result;
  }
  public static type remove_null_type(final type the_type) {
    assert type_utilities.is_union(the_type);
    final type_flavor union_flavor = the_type.get_flavor();
    final immutable_list<abstract_value> the_values = type_utilities.get_union_parameters(the_type);
    assert ideal.machine.elements.runtime_util.values_equal(the_values.size(), 2);
    final type the_null_type = (type) the_values.get(1);
    assert the_null_type.principal() == common_types.null_type();
    type result = (type) the_values.get(0);
    if (union_flavor != flavor.nameonly_flavor) {
      result = result.get_flavored(union_flavor);
    }
    return result;
  }
  public static boolean is_bootstrapped() {
    return common_types.ENTITY_TYPE.get_declaration() != null;
  }
  public static boolean is_initialized() {
    return common_types.context != null;
  }
  public static type_declaration_context get_context() {
    return common_types.context;
  }
}
