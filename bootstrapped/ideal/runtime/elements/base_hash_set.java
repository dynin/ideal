// Autogenerated from runtime/elements/base_hash_set.i

package ideal.runtime.elements;

import ideal.library.elements.*;
import ideal.machine.elements.array;

import javax.annotation.Nullable;

public abstract class base_hash_set<element_type> implements readonly_set<element_type> {
  public static class parameters {
    public static final int default_size = 16;
  }
  protected static class hash_cell<element_type> {
    protected final element_type the_value;
    protected final int the_hash;
    protected @Nullable base_hash_set.hash_cell<element_type> next;
    public hash_cell(final element_type the_value, final int the_hash, final @Nullable base_hash_set.hash_cell<element_type> next) {
      this.the_value = the_value;
      this.the_hash = the_hash;
      this.next = next;
    }
    public hash_cell(final element_type the_value, final int the_hash) {
      this(the_value, the_hash, null);
    }
  }
  protected static class set_state<element_type> {
    public boolean writable;
    public array<base_hash_set.hash_cell<element_type>> the_buckets;
    public int size;
    public set_state(final int initial_size) {
      writable = true;
      the_buckets = new array<base_hash_set.hash_cell<element_type>>(initial_size);
      size = 0;
    }
    public set_state() {
      this(base_hash_set.parameters.default_size);
    }
    protected void clear() {
      if (size != 0) {
        the_buckets = new array<base_hash_set.hash_cell<element_type>>(base_hash_set.parameters.default_size);
        size = 0;
      }
    }
    public void reserve(final int reserve_size) {
      if (the_buckets.size >= reserve_size) {
        return;
      }
      int new_size = the_buckets.size * 2;
      if (new_size < reserve_size) {
        new_size = reserve_size;
      }
      final array<base_hash_set.hash_cell<element_type>> old_buckets = the_buckets;
      the_buckets = new array<base_hash_set.hash_cell<element_type>>(new_size);
      for (int i = 0; i < old_buckets.size; i += 1) {
        @Nullable base_hash_set.hash_cell<element_type> bucket = old_buckets.at(i).get();
        while (bucket != null) {
          final @Nullable base_hash_set.hash_cell<element_type> old_next = bucket.next;
          final int new_index = bucket_index(bucket.the_hash);
          bucket.next = the_buckets.at(new_index).get();
          the_buckets.set(new_index, bucket);
          bucket = old_next;
        }
      }
      old_buckets.scrub(0, old_buckets.size);
    }
    protected int bucket_index(final int hash) {
      final int bucket_size = the_buckets.size;
      final int index = ((hash % bucket_size) + bucket_size) % bucket_size;
      assert index >= 0;
      return index;
    }
    protected base_hash_set.set_state<element_type> copy() {
      final base_hash_set.set_state<element_type> result = new base_hash_set.set_state<element_type>(the_buckets.size);
      for (int i = 0; i < the_buckets.size; i += 1) {
        @Nullable base_hash_set.hash_cell<element_type> bucket = the_buckets.at(i).get();
        while (bucket != null) {
          final base_hash_set.hash_cell<element_type> new_cell = new base_hash_set.hash_cell<element_type>(bucket.the_value, bucket.the_hash, result.the_buckets.at(i).get());
          result.the_buckets.set(i, new_cell);
          bucket = bucket.next;
        }
      }
      result.size = this.size;
      return result;
    }
  }
  protected final equivalence_with_hash<element_type> equivalence;
  protected base_hash_set.set_state<element_type> state;
  protected base_hash_set(final equivalence_with_hash<element_type> equivalence) {
    this.equivalence = equivalence;
    this.state = new base_hash_set.set_state<element_type>();
  }
  protected base_hash_set(final equivalence_with_hash<element_type> equivalence, final base_hash_set.set_state<element_type> state) {
    this.equivalence = equivalence;
    this.state = state;
  }
  public @Override int size() {
    return state.size;
  }
  public @Override boolean is_empty() {
    return state.size == 0;
  }
  public @Override boolean is_not_empty() {
    return state.size != 0;
  }
  public @Override immutable_list<element_type> elements() {
    if (is_empty()) {
      return new empty<element_type>();
    }
    final base_list<element_type> result = new base_list<element_type>();
    for (int i = 0; i < state.the_buckets.size; i += 1) {
      for (@Nullable base_hash_set.hash_cell<element_type> entry = state.the_buckets.at(i).get(); entry != null; entry = entry.next) {
        result.append(entry.the_value);
      }
    }
    return result.frozen_copy();
  }
  public @Override immutable_set<element_type> frozen_copy() {
    return new immutable_hash_set<element_type>(equivalence, state);
  }
  public @Override boolean contains(final element_type key) {
    assert key != null;
    final int hash = equivalence.hash(key);
    final @Nullable base_hash_set.hash_cell<element_type> bucket = state.the_buckets.at(state.bucket_index(hash)).get();
    for (@Nullable base_hash_set.hash_cell<element_type> entry = bucket; entry != null; entry = entry.next) {
      if (hash == entry.the_hash && equivalence.call(key, entry.the_value)) {
        return true;
      }
    }
    return false;
  }
}
