// Autogenerated from runtime/elements/base_hash_set.i

package ideal.runtime.elements;

import ideal.library.elements.*;
import ideal.machine.elements.array;

import javax.annotation.Nullable;

public abstract class base_hash_set<element_type> implements readonly_set<element_type> {
  public static class parameters {
    public static final Integer default_size = 16;
  }
  protected static class hash_cell<element_type> {
    protected final element_type the_value;
    protected final Integer the_hash;
    protected @Nullable base_hash_set.hash_cell<element_type> next;
    public hash_cell(final element_type the_value, final Integer the_hash, final @Nullable base_hash_set.hash_cell<element_type> next) {
      this.the_value = the_value;
      this.the_hash = the_hash;
      this.next = next;
    }
    public hash_cell(final element_type the_value, final Integer the_hash) {
      this(the_value, the_hash, null);
    }
  }
  protected static class set_state<element_type> {
    public boolean writable;
    public array<base_hash_set.hash_cell<element_type>> the_buckets;
    public Integer size;
    public set_state(final Integer initial_size) {
      this.writable = true;
      this.the_buckets = new array<base_hash_set.hash_cell<element_type>>(initial_size);
      this.size = 0;
    }
    public set_state() {
      this(base_hash_set.parameters.default_size);
    }
    protected void clear() {
      if (!ideal.machine.elements.runtime_util.values_equal(this.size, 0)) {
        this.the_buckets = new array<base_hash_set.hash_cell<element_type>>(base_hash_set.parameters.default_size);
        this.size = 0;
      }
    }
    public void reserve(final Integer reserve_size) {
      if (this.the_buckets.size >= reserve_size) {
        return;
      }
      Integer new_size = this.the_buckets.size * 2;
      if (new_size < reserve_size) {
        new_size = reserve_size;
      }
      final array<base_hash_set.hash_cell<element_type>> old_buckets = this.the_buckets;
      this.the_buckets = new array<base_hash_set.hash_cell<element_type>>(new_size);
      for (Integer i = 0; i < old_buckets.size; i += 1) {
        @Nullable base_hash_set.hash_cell<element_type> bucket = old_buckets.at(i).get();
        while (bucket != null) {
          final @Nullable base_hash_set.hash_cell<element_type> old_next = bucket.next;
          final Integer new_index = this.bucket_index(bucket.the_hash);
          bucket.next = this.the_buckets.at(new_index).get();
          this.the_buckets.set(new_index, bucket);
          bucket = old_next;
        }
      }
      old_buckets.scrub(0, old_buckets.size);
    }
    protected Integer bucket_index(final Integer hash) {
      final Integer bucket_size = this.the_buckets.size;
      final Integer index = ((hash % bucket_size) + bucket_size) % bucket_size;
      assert index >= 0;
      return index;
    }
    protected base_hash_set.set_state<element_type> copy() {
      final base_hash_set.set_state<element_type> result = new base_hash_set.set_state<element_type>(this.the_buckets.size);
      for (Integer i = 0; i < this.the_buckets.size; i += 1) {
        @Nullable base_hash_set.hash_cell<element_type> bucket = this.the_buckets.at(i).get();
        while (bucket != null) {
          final base_hash_set.hash_cell<element_type> new_cell = new base_hash_set.hash_cell<element_type>(bucket.the_value, bucket.the_hash, result.the_buckets.at(i).get());
          result.the_buckets.set(i, new_cell);
          bucket = bucket.next;
        }
      }
      result.size = this.size;
      return result;
    }
  }
  protected final equivalence_with_hash<element_type> equivalence;
  protected base_hash_set.set_state<element_type> state;
  protected base_hash_set(final equivalence_with_hash<element_type> equivalence) {
    this.equivalence = equivalence;
    this.state = new base_hash_set.set_state<element_type>();
  }
  protected base_hash_set(final equivalence_with_hash<element_type> equivalence, final base_hash_set.set_state<element_type> state) {
    this.equivalence = equivalence;
    this.state = state;
  }
  public @Override Integer size() {
    return this.state.size;
  }
  public @Override boolean is_empty() {
    return ideal.machine.elements.runtime_util.values_equal(this.state.size, 0);
  }
  public @Override boolean is_not_empty() {
    return !ideal.machine.elements.runtime_util.values_equal(this.state.size, 0);
  }
  public @Override immutable_list<element_type> elements() {
    if (this.is_empty()) {
      return new empty<element_type>();
    }
    final base_list<element_type> result = new base_list<element_type>();
    for (Integer i = 0; i < this.state.the_buckets.size; i += 1) {
      for (@Nullable base_hash_set.hash_cell<element_type> entry = this.state.the_buckets.at(i).get(); entry != null; entry = entry.next) {
        result.append(entry.the_value);
      }
    }
    return result.frozen_copy();
  }
  public @Override immutable_set<element_type> frozen_copy() {
    return new immutable_hash_set<element_type>(this.equivalence, this.state);
  }
  public @Override boolean contains(final element_type key) {
    assert key != null;
    final Integer hash = this.equivalence.hash(key);
    final @Nullable base_hash_set.hash_cell<element_type> bucket = this.state.the_buckets.at(this.state.bucket_index(hash)).get();
    for (@Nullable base_hash_set.hash_cell<element_type> entry = bucket; entry != null; entry = entry.next) {
      if (ideal.machine.elements.runtime_util.values_equal(hash, entry.the_hash) && ((function2<Boolean, element_type, element_type>) (Object) this.equivalence).call(key, entry.the_value)) {
        return true;
      }
    }
    return false;
  }
}
