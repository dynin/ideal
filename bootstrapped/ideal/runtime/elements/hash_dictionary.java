// Autogenerated from runtime/elements/hash_dictionary.i

package ideal.runtime.elements;

import ideal.library.elements.*;
import ideal.machine.elements.runtime_util;

import javax.annotation.Nullable;

public class hash_dictionary<key_type, value_type> extends base_hash_dictionary<key_type, value_type> implements dictionary<key_type, value_type> {
  public hash_dictionary(final equivalence_with_hash<key_type> equivalence) {
    super(equivalence);
  }
  public hash_dictionary() {
    super((equivalence_with_hash<key_type>) (Object) runtime_util.default_equivalence);
  }
  private void copy_on_write() {
    if (!this.state.writable) {
      this.state = this.state.copy();
      assert this.state.writable;
    }
  }
  public @Override void clear() {
    this.copy_on_write();
    this.state.clear();
  }
  public @Override @Nullable value_type put(final key_type key, final value_type value) {
    this.copy_on_write();
    this.state.reserve(this.size() + 1);
    final Integer hash = this.equivalence.hash(key);
    final Integer index = this.state.bucket_index(hash);
    @Nullable base_hash_dictionary.hash_cell<key_type, value_type> entry = this.state.the_buckets.at(index).get();
    if (entry == null) {
      this.state.the_buckets.set(index, new base_hash_dictionary.hash_cell<key_type, value_type>(key, hash, value));
      this.state.size += 1;
      return null;
    }
    while (true) {
      if (runtime_util.values_equal(hash, entry.the_key_hash) && ((function2<Boolean, key_type, key_type>) (Object) this.equivalence).call(key, entry.key())) {
        final value_type old_value = entry.value();
        entry.set_value(value);
        return old_value;
      }
      final @Nullable base_hash_dictionary.hash_cell<key_type, value_type> next = entry.next;
      if (next == null) {
        entry.next = new base_hash_dictionary.hash_cell<key_type, value_type>(key, hash, value);
        this.state.size += 1;
        return null;
      } else {
        entry = next;
      }
    }
  }
  public @Override @Nullable value_type remove(final key_type key) {
    this.copy_on_write();
    final Integer hash = this.equivalence.hash(key);
    final Integer index = this.state.bucket_index(hash);
    @Nullable base_hash_dictionary.hash_cell<key_type, value_type> entry = this.state.the_buckets.at(index).get();
    if (entry == null) {
      return null;
    }
    if (runtime_util.values_equal(hash, entry.the_key_hash) && ((function2<Boolean, key_type, key_type>) (Object) this.equivalence).call(key, entry.key())) {
      final value_type old_value = entry.value();
      this.state.the_buckets.set(index, entry.next);
      final Integer new_size = this.state.size - 1;
      assert new_size >= 0;
      this.state.size = new_size;
      return old_value;
    }
    while (true) {
      final @Nullable base_hash_dictionary.hash_cell<key_type, value_type> next_entry = entry.next;
      if (next_entry == null) {
        return null;
      }
      if (runtime_util.values_equal(hash, next_entry.the_key_hash) && ((function2<Boolean, key_type, key_type>) (Object) this.equivalence).call(key, next_entry.key())) {
        final value_type old_value = next_entry.value();
        entry.next = next_entry.next;
        final Integer new_size = this.state.size - 1;
        assert new_size >= 0;
        this.state.size = new_size;
        return old_value;
      }
      entry = next_entry;
    }
  }
}
