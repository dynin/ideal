// Autogenerated from isource/runtime/elements/hash_set.i

package ideal.runtime.elements;

import ideal.library.elements.*;
import ideal.machine.elements.runtime_util;

import javax.annotation.Nullable;

public class hash_set<element_type> extends base_hash_set<element_type> implements set<element_type> {
  public hash_set(final equivalence_with_hash<element_type> equivalence) {
    super(equivalence);
  }
  public hash_set() {
    super((equivalence_with_hash<element_type>) (any_value) runtime_util.default_equivalence);
  }
  private void copy_on_write() {
    if (!state.writable) {
      state = state.copy();
      assert state.writable;
    }
  }
  public @Override void clear() {
    copy_on_write();
    state.clear();
  }
  public @Override void add(final element_type the_value) {
    copy_on_write();
    state.reserve(size() + 1);
    do_add(the_value);
  }
  public @Override void add_all(final readonly_collection<element_type> the_collection) {
    copy_on_write();
    state.reserve(size() + the_collection.size());
    final immutable_list<element_type> new_elements = the_collection.elements();
    for (int i = 0; i < new_elements.size(); i += 1) {
      do_add(new_elements.get(i));
    }
  }
  private void do_add(final element_type the_value) {
    final int hash = equivalence.hash(the_value);
    final int index = state.bucket_index(hash);
    @Nullable base_hash_set.hash_cell<element_type> entry = state.the_buckets.at(index).get();
    if (entry == null) {
      state.the_buckets.set(index, new hash_cell<element_type>(the_value, hash));
      state.size += 1;
      return;
    }
    while (true) {
      if (hash == entry.the_hash && equivalence.call(the_value, entry.the_value)) {
        return;
      }
      final @Nullable base_hash_set.hash_cell<element_type> next = entry.next;
      if (next == null) {
        entry.next = new hash_cell<element_type>(the_value, hash);
        state.size += 1;
        return;
      } else {
        entry = next;
      }
    }
  }
}
