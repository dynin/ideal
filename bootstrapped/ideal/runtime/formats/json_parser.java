// Autogenerated from runtime/formats/json_parser.i

package ideal.runtime.formats;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.runtime.elements.*;
import ideal.runtime.patterns.list_pattern;
import ideal.machine.channels.string_writer;

import javax.annotation.Nullable;

public class json_parser {
  public final character_handler the_character_handler;
  public list<Object> tokens;
  public @Nullable string error;
  public json_parser(final character_handler the_character_handler) {
    this.the_character_handler = the_character_handler;
    this.tokens = new base_list<Object>();
  }
  public boolean has_error() {
    return this.error != null;
  }
  private void tokenize(final string input) {
    this.tokens.clear();
    int start = 0;
    while (start < input.size() && this.error == null) {
      start = this.scan(input, start);
    }
  }
  public list<Object> test_tokenize(final string input) {
    this.tokenize(input);
    assert !this.has_error();
    return this.tokens;
  }
  private int scan(final string input, final int start) {
    final char next = input.get(start);
    int index = start + 1;
    if (this.the_character_handler.is_whitespace(next)) {
      while (index < input.size() && this.the_character_handler.is_whitespace(input.get(index))) {
        index += 1;
      }
      return index;
    }
    if (next == '\"') {
      final string_writer result = new string_writer();
      while (index < input.size()) {
        final char next_in_input = input.get(index);
        if (next_in_input == '\"') {
          this.tokens.append(result.elements());
          return index + 1;
        } else if (next_in_input == '\\') {
          if (index >= input.size()) {
            this.report_error(new base_string("Escape at the end of input"));
            return index;
          }
          index += 1;
          final char escaped_character = input.get(index);
          if (escaped_character == '\"' || escaped_character == '\\' || escaped_character == '/') {
            result.write(escaped_character);
          } else if (escaped_character == 'b') {
            result.write('\b');
          } else if (escaped_character == 'f') {
            result.write('\f');
          } else if (escaped_character == 'n') {
            result.write('\n');
          } else if (escaped_character == 'r') {
            result.write('\r');
          } else if (escaped_character == 't') {
            result.write('\t');
          } else if (escaped_character == 'u') {
            if (index + 4 >= input.size()) {
              this.report_error(new base_string("Unicode escape at the end of input"));
              return index;
            }
            int code = this.hex_digit(input.get(index + 1));
            code = code * 16 + this.hex_digit(input.get(index + 2));
            code = code * 16 + this.hex_digit(input.get(index + 3));
            code = code * 16 + this.hex_digit(input.get(index + 4));
            result.write(this.the_character_handler.from_code(code));
            index += 4;
          } else {
            this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized escape character: "), escaped_character));
            return index;
          }
        } else {
          result.write(next_in_input);
        }
        index += 1;
      }
      this.report_error(new base_string("No closing quote in a string"));
      return index;
    }
    if (this.the_character_handler.is_digit(next)) {
      return this.parse_number(input, start, false);
    }
    if (next == '-') {
      if (index < input.size()) {
        return this.parse_number(input, index, true);
      } else {
        this.report_error(new base_string("Minus at the end of input"));
        return index;
      }
    }
    if (next == json_token.OPEN_BRACE.token) {
      this.tokens.append(json_token.OPEN_BRACE);
      return index;
    }
    if (next == json_token.CLOSE_BRACE.token) {
      this.tokens.append(json_token.CLOSE_BRACE);
      return index;
    }
    if (next == json_token.OPEN_BRACKET.token) {
      this.tokens.append(json_token.OPEN_BRACKET);
      return index;
    }
    if (next == json_token.CLOSE_BRACKET.token) {
      this.tokens.append(json_token.CLOSE_BRACKET);
      return index;
    }
    if (next == json_token.COMMA.token) {
      this.tokens.append(json_token.COMMA);
      return index;
    }
    if (next == json_token.COLON.token) {
      this.tokens.append(json_token.COLON);
      return index;
    }
    if (next == 't') {
      return this.parse_symbol(input, start, new base_string("true"), true);
    }
    if (next == 'f') {
      return this.parse_symbol(input, start, new base_string("false"), false);
    }
    if (next == 'n') {
      return this.parse_symbol(input, start, new base_string("null"), null);
    }
    this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized character in a string: "), next));
    return index;
  }
  private int hex_digit(final char the_character) {
    final @Nullable Integer result = this.the_character_handler.from_digit(the_character, 16);
    if (result >= 0) {
      return result;
    } else {
      this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized character in hex escape: "), the_character));
      return 0;
    }
  }
  private int parse_number(final string input, final int start, final boolean negate) {
    final char next = input.get(start);
    if (!this.the_character_handler.is_digit(next)) {
      this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized digit: "), next));
      return start;
    }
    final @Nullable Integer digit = this.the_character_handler.from_digit(next, radix.DEFAULT_RADIX);
    assert digit >= 0;
    int result = digit;
    int index = start + 1;
    while (index < input.size() && this.the_character_handler.is_digit(input.get(index))) {
      final @Nullable Integer next_digit = this.the_character_handler.from_digit(input.get(index), radix.DEFAULT_RADIX);
      assert next_digit >= 0;
      result = result * radix.DEFAULT_RADIX + next_digit;
      index += 1;
    }
    this.tokens.append(negate ? -result : result);
    return index;
  }
  private int parse_symbol(final string input, final int start, final string symbol, final Object value) {
    final @Nullable Integer prefix = new list_pattern<Character>(symbol).match_prefix(input.skip(start));
    if (prefix != null) {
      if (prefix == symbol.size()) {
        this.tokens.append(value);
        return start + prefix;
      }
    }
    this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Can\'t parse symbol: "), symbol));
    return start + 1;
  }
  private void report_error(final string message) {
    this.error = message;
  }
}
