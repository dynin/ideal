// Autogenerated from runtime/formats/json_parser.i

package ideal.runtime.formats;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.library.formats.*;
import ideal.runtime.elements.*;
import ideal.runtime.patterns.list_pattern;
import ideal.machine.channels.string_writer;

import javax.annotation.Nullable;

public class json_parser {
  public static class parse_result {
    public final Object the_json_data;
    public final Integer end_index;
    public parse_result(final Object the_json_data, final Integer end_index) {
      this.the_json_data = the_json_data;
      this.end_index = end_index;
    }
  }
  public final character_handler the_character_handler;
  public list<Object> tokens;
  public @Nullable string error;
  public json_parser(final character_handler the_character_handler) {
    this.the_character_handler = the_character_handler;
    this.tokens = new base_list<Object>();
  }
  public boolean has_error() {
    return this.error != null;
  }
  private void tokenize(final string input) {
    this.tokens.clear();
    Integer start = 0;
    while (start < input.size() && this.error == null) {
      start = this.scan(input, start);
    }
  }
  public list<Object> test_tokenize(final string input) {
    this.tokenize(input);
    assert !this.has_error();
    return this.tokens;
  }
  public Object parse(final string input) {
    this.tokenize(input);
    assert !this.has_error();
    final json_parser.parse_result result = this.parse_value(0);
    assert !this.has_error();
    return result.the_json_data;
  }
  private Integer scan(final string input, final Integer start) {
    final char next = input.get(start);
    Integer index = start + 1;
    if (this.the_character_handler.is_whitespace(next)) {
      while (index < input.size() && this.the_character_handler.is_whitespace(input.get(index))) {
        index += 1;
      }
      return index;
    }
    if (next == '\"') {
      final string_writer result = new string_writer();
      while (index < input.size()) {
        final char next_in_input = input.get(index);
        if (next_in_input == '\"') {
          this.tokens.append(result.elements());
          return index + 1;
        } else if (next_in_input == '\\') {
          if (index >= input.size()) {
            this.report_error(new base_string("Escape at the end of input"));
            return index;
          }
          index += 1;
          final char escaped_character = input.get(index);
          if (escaped_character == '\"' || escaped_character == '\\' || escaped_character == '/') {
            result.write(escaped_character);
          } else if (escaped_character == 'b') {
            result.write('\b');
          } else if (escaped_character == 'f') {
            result.write('\f');
          } else if (escaped_character == 'n') {
            result.write('\n');
          } else if (escaped_character == 'r') {
            result.write('\r');
          } else if (escaped_character == 't') {
            result.write('\t');
          } else if (escaped_character == 'u') {
            if (index + 4 >= input.size()) {
              this.report_error(new base_string("Unicode escape at the end of input"));
              return index;
            }
            Integer code = this.hex_digit(input.get(index + 1));
            code = code * 16 + this.hex_digit(input.get(index + 2));
            code = code * 16 + this.hex_digit(input.get(index + 3));
            code = code * 16 + this.hex_digit(input.get(index + 4));
            result.write(this.the_character_handler.from_code(code));
            index += 4;
          } else {
            this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized escape character: "), escaped_character));
            return index;
          }
        } else {
          result.write(next_in_input);
        }
        index += 1;
      }
      this.report_error(new base_string("No closing quote in a string"));
      return index;
    }
    if (this.the_character_handler.is_digit(next)) {
      return this.scan_number(input, start, false);
    }
    if (next == '-') {
      if (index < input.size()) {
        return this.scan_number(input, index, true);
      } else {
        this.report_error(new base_string("Minus at the end of input"));
        return index;
      }
    }
    if (next == json_token.OPEN_BRACE.the_character) {
      this.tokens.append(json_token.OPEN_BRACE);
      return index;
    }
    if (next == json_token.CLOSE_BRACE.the_character) {
      this.tokens.append(json_token.CLOSE_BRACE);
      return index;
    }
    if (next == json_token.OPEN_BRACKET.the_character) {
      this.tokens.append(json_token.OPEN_BRACKET);
      return index;
    }
    if (next == json_token.CLOSE_BRACKET.the_character) {
      this.tokens.append(json_token.CLOSE_BRACKET);
      return index;
    }
    if (next == json_token.COMMA.the_character) {
      this.tokens.append(json_token.COMMA);
      return index;
    }
    if (next == json_token.COLON.the_character) {
      this.tokens.append(json_token.COLON);
      return index;
    }
    if (next == 't') {
      return this.scan_symbol(input, start, new base_string("true"), true);
    }
    if (next == 'f') {
      return this.scan_symbol(input, start, new base_string("false"), false);
    }
    if (next == 'n') {
      return this.scan_symbol(input, start, new base_string("null"), null);
    }
    this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized character in a string: "), next));
    return index;
  }
  private Integer hex_digit(final char the_character) {
    final @Nullable Integer result = this.the_character_handler.from_digit(the_character, 16);
    if (result >= 0) {
      return result;
    } else {
      this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized character in hex escape: "), the_character));
      return 0;
    }
  }
  private Integer scan_number(final string input, final Integer start, final boolean negate) {
    final char next = input.get(start);
    if (!this.the_character_handler.is_digit(next)) {
      this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unrecognized digit: "), next));
      return start;
    }
    final @Nullable Integer digit = this.the_character_handler.from_digit(next, radix.DEFAULT_RADIX);
    assert digit >= 0;
    Integer result = digit;
    Integer index = start + 1;
    while (index < input.size() && this.the_character_handler.is_digit(input.get(index))) {
      final @Nullable Integer next_digit = this.the_character_handler.from_digit(input.get(index), radix.DEFAULT_RADIX);
      assert next_digit >= 0;
      result = result * radix.DEFAULT_RADIX + next_digit;
      index += 1;
    }
    this.tokens.append(negate ? -result : result);
    return index;
  }
  private Integer scan_symbol(final string input, final Integer start, final string symbol, final Object value) {
    final @Nullable Integer prefix = new list_pattern<Character>(symbol).match_prefix(input.skip(start));
    if (prefix != null) {
      if (ideal.machine.elements.runtime_util.values_equal(prefix, symbol.size())) {
        this.tokens.append(value);
        return start + prefix;
      }
    }
    this.report_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Can\'t scan symbol: "), symbol));
    return start + 1;
  }
  private json_parser.parse_result parse_value(final Integer start) {
    if (start >= this.tokens.size()) {
      return this.parse_error(new base_string("End of tokens when parsing value"));
    }
    final Object next = this.tokens.at(start).get();
    if (next == json_token.OPEN_BRACE) {
      return this.parse_object(start);
    } else if (next == json_token.OPEN_BRACKET) {
      return this.parse_array(start);
    }
    if (next instanceof json_token) {
      return this.parse_error(ideal.machine.elements.runtime_util.concatenate(new base_string("Unexpected token: "), ((json_token) next)));
    }
    return new json_parser.parse_result(next, start + 1);
  }
  private json_parser.parse_result parse_object(final Integer start) {
    if (this.tokens.at(start).get() != json_token.OPEN_BRACE) {
      return this.parse_error(new base_string("Open brace expected"));
    }
    final json_object result = new json_object_impl();
    Integer index = start + 1;
    while (index < this.tokens.size()) {
      final Object next = this.tokens.at(index).get();
      if (next == json_token.CLOSE_BRACE) {
        return new json_parser.parse_result(result, index + 1);
      }
      if (!(next instanceof string)) {
        return this.parse_error(new base_string("Expected string identifier in object"));
      }
      index += 1;
      while (index >= this.tokens.size() || this.tokens.at(index).get() != json_token.COLON) {
        return this.parse_error(new base_string("Expected colon in object"));
      }
      index += 1;
      final json_parser.parse_result element = this.parse_value(index);
      if (this.has_error()) {
        return element;
      }
      result.put(((string) next), element.the_json_data);
      index = element.end_index;
      if (index >= this.tokens.size()) {
        return this.parse_error(new base_string("No closing brace in object"));
      }
      if (this.tokens.at(index).get() == json_token.CLOSE_BRACE) {
        return new json_parser.parse_result(result, index + 1);
      }
      if (this.tokens.at(index).get() != json_token.COMMA) {
        return this.parse_error(new base_string("Expected comma in object"));
      }
      index += 1;
    }
    return this.parse_error(new base_string("No closing brace in object"));
  }
  private json_parser.parse_result parse_array(final Integer start) {
    if (this.tokens.at(start).get() != json_token.OPEN_BRACKET) {
      return this.parse_error(new base_string("Open bracket expected"));
    }
    final json_array result = new json_array_impl();
    Integer index = start + 1;
    while (index < this.tokens.size()) {
      if (this.tokens.at(index).get() == json_token.CLOSE_BRACKET) {
        return new json_parser.parse_result(result, index + 1);
      }
      final json_parser.parse_result element = this.parse_value(index);
      if (this.has_error()) {
        return element;
      }
      result.append(element.the_json_data);
      index = element.end_index;
      if (index >= this.tokens.size()) {
        return this.parse_error(new base_string("No closing bracket in array"));
      }
      if (this.tokens.at(index).get() == json_token.CLOSE_BRACKET) {
        return new json_parser.parse_result(result, index + 1);
      }
      if (this.tokens.at(index).get() != json_token.COMMA) {
        return this.parse_error(new base_string("Expected comma in array"));
      }
      index += 1;
    }
    return this.parse_error(new base_string("No closing bracket in array"));
  }
  private void report_error(final string message) {
    this.error = message;
  }
  private json_parser.parse_result parse_error(final string message) {
    this.report_error(message);
    return new json_parser.parse_result(message, 0);
  }
}
