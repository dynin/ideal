// Autogenerated from runtime/texts/markup_formatter.i

package ideal.runtime.texts;

import ideal.library.elements.*;
import ideal.library.texts.*;
import ideal.runtime.elements.*;
import ideal.library.channels.output;
import ideal.machine.channels.string_writer;
import ideal.machine.elements.runtime_util;

import javax.annotation.Nullable;

public class markup_formatter extends text_formatter {
  public static final string OPEN_START_TAG = new base_string("<");
  public static final string OPEN_END_TAG = new base_string("</");
  public static final string ATTRIBUTE_SEPARATOR = new base_string(" ");
  public static final string ATTRIBUTE_START = new base_string("='");
  public static final string ATTRIBUTE_END = new base_string("'");
  public static final string CLOSE_TAG = new base_string(">");
  public static final string CLOSE_SELF_CLOSING_TAG = new base_string(" />");
  public static final string DEFAULT_INDENT = new base_string(" ");
  public markup_formatter(final output<Character> out, final string spaces) {
    super(out, spaces);
  }
  public markup_formatter(final output<Character> out) {
    this(out, DEFAULT_INDENT);
  }
  public @Override Void process_string(final string s) {
    write_escaped(s);
    return null;
  }
  public @Override Void process_element(final text_element element) {
    final boolean is_block = text_util.is_block(element);
    final immutable_dictionary<attribute_id, string> attributes = element.attributes();
    final @Nullable text_fragment children = element.children();
    if (children == null) {
      write_self_closing_tag(element, attributes);
      if (is_block) {
        write_newline();
      }
    } else {
      if (is_block) {
        if (!first) {
          write_newline();
        }
        if (indent > 0) {
          do_indent();
        }
        write_start_tag(element, attributes);
        write_newline();
        do_indent();
      } else {
        write_start_tag(element, attributes);
      }
      process(children);
      if (is_block) {
        if (!first) {
          write_newline();
        }
        do_unindent();
        write_end_tag(element);
        write_newline();
        if (indent > 0) {
          do_unindent();
        }
      } else {
        write_end_tag(element);
      }
    }
    return null;
  }
  private void do_indent() {
    indent += 1;
  }
  private void do_unindent() {
    final int new_indent = indent - 1;
    assert new_indent >= 0;
    indent = new_indent;
  }
  public @Override Void process_special(final special_text t) {
    write_string(t.to_markup());
    return null;
  }
  private void write_start_tag(final text_element element, final readonly_dictionary<attribute_id, string> attributes) {
    write_string(OPEN_START_TAG);
    write_escaped(element.get_id().short_name());
    write_tag_attributes(attributes);
    write_string(CLOSE_TAG);
  }
  private void write_end_tag(final text_element element) {
    write_string(OPEN_END_TAG);
    write_escaped(element.get_id().short_name());
    write_string(CLOSE_TAG);
  }
  private void write_self_closing_tag(final text_element element, final readonly_dictionary<attribute_id, string> attributes) {
    write_string(OPEN_START_TAG);
    write_escaped(element.get_id().short_name());
    write_tag_attributes(attributes);
    write_string(CLOSE_SELF_CLOSING_TAG);
  }
  private void write_tag_attributes(final readonly_dictionary<attribute_id, string> attributes) {
    final immutable_list<dictionary.entry<attribute_id, string>> attributes_list = attributes.elements();
    for (int i = 0; i < attributes_list.size(); i += 1) {
      final dictionary.entry<attribute_id, string> attribute = attributes_list.get(i);
      write_string(ATTRIBUTE_SEPARATOR);
      write_escaped(attribute.key().short_name());
      write_string(ATTRIBUTE_START);
      write_escaped(attribute.value());
      write_string(ATTRIBUTE_END);
    }
  }
  private void write_escaped(final string s) {
    write_string(runtime_util.escape_markup(s));
  }
}
