// Autogenerated from isource/runtime/texts/markup_formatter.i

package ideal.runtime.texts;

import ideal.library.elements.*;
import ideal.library.texts.*;
import ideal.runtime.elements.*;
import ideal.library.channels.output;
import ideal.machine.channels.string_writer;
import ideal.machine.elements.runtime_util;

public class markup_formatter extends text_formatter {
  public static final string OPEN_START_TAG = new base_string("<");
  public static final string OPEN_END_TAG = new base_string("</");
  public static final string ATTRIBUTE_SEPARATOR = new base_string(" ");
  public static final string ATTRIBUTE_START = new base_string("='");
  public static final string ATTRIBUTE_END = new base_string("'");
  public static final string CLOSE_TAG = new base_string(">");
  public static final string CLOSE_SELF_CLOSING_TAG = new base_string(" />");
  public static final string DEFAULT_INDENT = new base_string(" ");
  public markup_formatter(final output<Character> out, final string spaces) {
    super(out, spaces);
  }
  public markup_formatter(final output<Character> out) {
    this(out, DEFAULT_INDENT);
  }
  public @Override Void process_string(final string s) {
    write_escaped(s);
    return null;
  }
  public @Override Void process_element(final text_element element) {
    final boolean is_block = text_util.is_block(element);
    final readonly_list<text_element> attributes = get_attributes(element.children());
    final readonly_list<text_node> non_attributes = skip_attributes(element.children());
    if (non_attributes.is_empty()) {
      write_self_closing_tag(element, attributes);
      if (is_block) {
        write_newline();
      }
    } else {
      if (is_block) {
        if (!first) {
          write_newline();
        }
        if (indent > 0) {
          do_indent();
        }
        write_start_tag(element, attributes);
        write_newline();
        do_indent();
      } else {
        write_start_tag(element, attributes);
      }
      process_all(non_attributes);
      if (is_block) {
        if (!first) {
          write_newline();
        }
        do_unindent();
        write_end_tag(element);
        write_newline();
        if (indent > 0) {
          do_unindent();
        }
      } else {
        write_end_tag(element);
      }
    }
    return null;
  }
  private void do_indent() {
    indent += 1;
  }
  private void do_unindent() {
    final int new_indent = indent - 1;
    assert new_indent >= 0;
    indent = new_indent;
  }
  private static boolean is_attribute(final text_node node) {
    if (node instanceof text_element) {
      return ((text_element) node).get_id() instanceof attribute_id;
    } else {
      return false;
    }
  }
  private static readonly_list<text_element> get_attributes(final readonly_list<text_node> nodes) {
    final base_list<text_element> result = new base_list<text_element>();
    for (int i = 0; i < nodes.size(); i += 1) {
      if (is_attribute(nodes.get(i))) {
        result.append((text_element) nodes.get(i));
      }
    }
    return result;
  }
  private static readonly_list<text_node> skip_attributes(final readonly_list<text_node> nodes) {
    int i = 0;
    while (i < nodes.size() && is_attribute(nodes.get(i))) {
      i += 1;
    }
    for (int j = i; j < nodes.size(); j += 1) {
      assert !is_attribute(nodes.get(j));
    }
    return nodes.skip(i);
  }
  public @Override Void process_special(final special_text t) {
    write_string(t.to_markup());
    return null;
  }
  private void write_start_tag(final text_element element, final readonly_list<text_element> attributes) {
    write_string(OPEN_START_TAG);
    write_escaped(element.get_id().short_name());
    write_tag_attributes(attributes);
    write_string(CLOSE_TAG);
  }
  private void write_end_tag(final text_element element) {
    write_string(OPEN_END_TAG);
    write_escaped(element.get_id().short_name());
    write_string(CLOSE_TAG);
  }
  private void write_self_closing_tag(final text_element element, final readonly_list<text_element> attributes) {
    write_string(OPEN_START_TAG);
    write_escaped(element.get_id().short_name());
    write_tag_attributes(attributes);
    write_string(CLOSE_SELF_CLOSING_TAG);
  }
  private void write_tag_attributes(final readonly_list<text_element> attributes) {
    for (int i = 0; i < attributes.size(); i += 1) {
      final text_element attribute = attributes.get(i);
      assert attribute.get_id() instanceof attribute_id;
      assert attribute.children().size() == 1;
      assert attribute.children().get(0) instanceof string;
      write_string(ATTRIBUTE_SEPARATOR);
      write_escaped(attribute.get_id().short_name());
      write_string(ATTRIBUTE_START);
      write_escaped((string) attribute.children().get(0));
      write_string(ATTRIBUTE_END);
    }
  }
  private void write_escaped(final string s) {
    write_string(runtime_util.escape_markup(s));
  }
}
