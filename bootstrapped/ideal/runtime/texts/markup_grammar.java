// Autogenerated from runtime/texts/markup_grammar.i

package ideal.runtime.texts;

import ideal.library.elements.*;
import ideal.library.characters.*;
import ideal.library.texts.*;
import ideal.runtime.elements.*;
import ideal.library.channels.output;
import ideal.library.patterns.*;
import ideal.runtime.patterns.*;
import ideal.runtime.texts.character_patterns.*;

import javax.annotation.Nullable;

public class markup_grammar {
  public final character_handler the_character_handler;
  public final dictionary<string, special_text> entities;
  public pattern<Character> document_pattern;
  public matcher<Character, special_text> entity_ref;
  public markup_grammar(final character_handler the_character_handler) {
    this.the_character_handler = the_character_handler;
    this.entities = new hash_dictionary<string, special_text>();
  }
  private boolean is_completed() {
    return this.document_pattern != null;
  }
  public void add_entities(final readonly_collection<special_text> new_entities) {
    assert !this.is_completed();
    {
      final readonly_list<special_text> the_entity_list = new_entities.elements();
      for (int the_entity_index = 0; the_entity_index < the_entity_list.size(); the_entity_index += 1) {
        final special_text the_entity = the_entity_list.get(the_entity_index);
        this.entities.put(the_entity.name(), the_entity);
      }
    }
  }
  public void complete() {
    assert !this.is_completed();
    this.document_pattern = this.document();
  }
  protected boolean name_start(final char c) {
    return this.the_character_handler.is_letter(c) || c == '_' || c == ':';
  }
  protected boolean name_char(final char c) {
    return this.the_character_handler.is_letter(c) || c == '.' || c == '-' || c == '_' || c == ':';
  }
  protected boolean content_char(final char c) {
    return c != '<' && c != '&';
  }
  protected boolean content_not_apos(final char c) {
    return c != '<' && c != '&' && c != '\'';
  }
  protected boolean content_not_quot(final char c) {
    return c != '<' && c != '&' && c != '\"';
  }
  public special_text make_entity_2nd(final readonly_list<any_value> the_list) {
    final string entity_name = (string) the_list.get(1);
    final @Nullable special_text entity = this.entities.get(entity_name);
    assert entity != null;
    return entity;
  }
  protected pattern<Character> document() {
    final pattern<Character> lt = character_patterns.one_character('<');
    final pattern<Character> gt = character_patterns.one_character('>');
    final pattern<Character> slash = character_patterns.one_character('/');
    final pattern<Character> amp = character_patterns.one_character('&');
    final pattern<Character> semicolon = character_patterns.one_character(';');
    final pattern<Character> quot = character_patterns.one_character('\"');
    final pattern<Character> apos = character_patterns.one_character('\'');
    final pattern<Character> eq = character_patterns.one_character('=');
    final pattern<Character> space_opt = character_patterns.zero_or_more(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.the_character_handler.is_whitespace(first);
      }
    });
    final matcher<Character, string> name = character_patterns.as_string(new sequence_pattern<Character>(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ character_patterns.one(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.name_start(first);
      }
    }), character_patterns.zero_or_more(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.name_char(first);
      }
    }) }))));
    this.entity_ref = new sequence_matcher<Character, special_text>(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ amp, name, semicolon })), new function1<special_text, readonly_list<any_value>>() {
      @Override public special_text call(readonly_list<any_value> first) {
        return markup_grammar.this.make_entity_2nd(first);
      }
    });
    final pattern<Character> equals = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ space_opt, eq, space_opt })));
    final pattern<Character> attribute_value_in_quot = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ quot, character_patterns.repeat_or_none(character_patterns.option(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ character_patterns.one_or_more(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.content_not_quot(first);
      }
    }), this.entity_ref })))), quot })));
    final pattern<Character> attribute_value_in_apos = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ apos, character_patterns.repeat_or_none(character_patterns.option(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ character_patterns.one_or_more(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.content_not_apos(first);
      }
    }), this.entity_ref })))), apos })));
    final option_pattern<Character> attribute_value = character_patterns.option(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ attribute_value_in_quot, attribute_value_in_apos })));
    final pattern<Character> attribute = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ name, equals, attribute_value })));
    final pattern<Character> attributes = character_patterns.repeat_or_none(character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ space_opt, attribute }))));
    final pattern<Character> empty_element = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ lt, name, attributes, space_opt, slash, gt })));
    final option_pattern<Character> element = character_patterns.option(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ empty_element })));
    final pattern<Character> char_data_opt = character_patterns.zero_or_more(new function1<Boolean, Character>() {
      @Override public Boolean call(Character first) {
        return markup_grammar.this.content_char(first);
      }
    });
    final pattern<Character> entity_ref_pattern = this.entity_ref;
    final option_pattern<Character> content_element = character_patterns.option(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ element, entity_ref_pattern })));
    final pattern<Character> content_tail = character_patterns.repeat_or_none(character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ content_element, char_data_opt }))));
    final pattern<Character> content = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ char_data_opt, content_tail })));
    final pattern<Character> start_tag = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ lt, name, attributes, space_opt, gt })));
    final pattern<Character> end_tag = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ lt, slash, name, space_opt, gt })));
    element.add_option(character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ start_tag, content, end_tag }))));
    final pattern<Character> result = character_patterns.sequence(new base_immutable_list<pattern<Character>>(new ideal.machine.elements.array<pattern<Character>>(new pattern[]{ space_opt, element, space_opt })));
    ((validatable) result).validate();
    return result;
  }
}
